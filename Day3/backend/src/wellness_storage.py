"""
Wellness data storage utility.
Handles reading and writing wellness check-in sessions to JSON.
"""

import json
import os
from datetime import datetime
from typing import Optional, List, Dict, Any
from pathlib import Path
import logging

logger = logging.getLogger("wellness-storage")

WELLNESS_LOG_FILE = "wellness_log.json"


class WellnessStorage:
    """Manages persistent storage of wellness check-in sessions."""
    
    def __init__(self, data_dir: str = "."):
        """
        Initialize wellness storage.
        
        Args:
            data_dir: Directory where wellness_log.json will be stored
        """
        self.data_dir = Path(data_dir)
        self.data_dir.mkdir(exist_ok=True)
        self.log_file = self.data_dir / WELLNESS_LOG_FILE
        self._ensure_log_file()
    
    def _ensure_log_file(self) -> None:
        """Create wellness log file if it doesn't exist."""
        if not self.log_file.exists():
            initial_data = {"sessions": []}
            with open(self.log_file, 'w') as f:
                json.dump(initial_data, f, indent=2)
            logger.info(f"Created new wellness log: {self.log_file}")
    
    def _read_log(self) -> Dict[str, Any]:
        """Read the wellness log file."""
        try:
            with open(self.log_file, 'r') as f:
                return json.load(f)
        except json.JSONDecodeError:
            logger.error("Corrupted wellness log, creating backup and starting fresh")
            # Backup corrupted file
            backup_file = self.log_file.with_suffix('.json.backup')
            self.log_file.rename(backup_file)
            self._ensure_log_file()
            return {"sessions": []}
        except Exception as e:
            logger.error(f"Error reading wellness log: {e}")
            return {"sessions": []}
    
    def _write_log(self, data: Dict[str, Any]) -> None:
        """Write data to wellness log file."""
        try:
            # Write to temp file first, then rename (atomic operation)
            temp_file = self.log_file.with_suffix('.json.tmp')
            with open(temp_file, 'w') as f:
                json.dump(data, f, indent=2)
            temp_file.replace(self.log_file)
            logger.info("Wellness log updated successfully")
        except Exception as e:
            logger.error(f"Error writing wellness log: {e}")
            raise
    
    def save_session(
        self,
        session_id: str,
        mood: str,
        energy_level: str,
        stress_factors: List[str],
        intentions: List[str],
        agent_summary: str,
        previous_reference: Optional[str] = None
    ) -> bool:
        """
        Save a wellness check-in session.
        
        Args:
            session_id: Unique session identifier
            mood: User's reported mood
            energy_level: User's energy level
            stress_factors: List of stress factors mentioned
            intentions: List of goals/intentions for the day
            agent_summary: Brief summary generated by agent
            previous_reference: Reference to previous session (if any)
        
        Returns:
            True if saved successfully, False otherwise
        """
        try:
            data = self._read_log()
            
            session_entry = {
                "session_id": session_id,
                "timestamp": datetime.now().isoformat(),
                "mood": mood,
                "energy_level": energy_level,
                "stress_factors": stress_factors,
                "intentions": intentions,
                "agent_summary": agent_summary,
                "previous_session_reference": previous_reference
            }
            
            data["sessions"].append(session_entry)
            self._write_log(data)
            
            logger.info(f"âœ… Saved wellness session: {session_id}")
            return True
            
        except Exception as e:
            logger.error(f"Failed to save session: {e}")
            return False
    
    def get_recent_sessions(self, limit: int = 5) -> List[Dict[str, Any]]:
        """
        Get the most recent wellness sessions.
        
        Args:
            limit: Maximum number of sessions to return
        
        Returns:
            List of recent session dictionaries
        """
        try:
            data = self._read_log()
            sessions = data.get("sessions", [])
            return sessions[-limit:] if sessions else []
        except Exception as e:
            logger.error(f"Error getting recent sessions: {e}")
            return []
    
    def get_last_session(self) -> Optional[Dict[str, Any]]:
        """
        Get the most recent wellness session.
        
        Returns:
            Last session dictionary or None if no sessions exist
        """
        sessions = self.get_recent_sessions(limit=1)
        return sessions[0] if sessions else None
    
    def get_all_sessions(self) -> List[Dict[str, Any]]:
        """
        Get all wellness sessions.
        
        Returns:
            List of all session dictionaries
        """
        try:
            data = self._read_log()
            return data.get("sessions", [])
        except Exception as e:
            logger.error(f"Error getting all sessions: {e}")
            return []
    
    def get_session_count(self) -> int:
        """Get total number of wellness sessions."""
        return len(self.get_all_sessions())
    
    def get_streak(self) -> int:
        """
        Calculate current check-in streak (consecutive days).
        
        Returns:
            Number of consecutive days with check-ins
        """
        try:
            sessions = self.get_all_sessions()
            if not sessions:
                return 0
            
            # Get unique dates (ignoring time)
            dates = []
            for session in sessions:
                timestamp = datetime.fromisoformat(session["timestamp"])
                dates.append(timestamp.date())
            
            # Remove duplicates and sort
            unique_dates = sorted(set(dates), reverse=True)
            
            if not unique_dates:
                return 0
            
            # Count consecutive days
            streak = 1
            for i in range(len(unique_dates) - 1):
                diff = (unique_dates[i] - unique_dates[i + 1]).days
                if diff == 1:
                    streak += 1
                else:
                    break
            
            return streak
            
        except Exception as e:
            logger.error(f"Error calculating streak: {e}")
            return 0
